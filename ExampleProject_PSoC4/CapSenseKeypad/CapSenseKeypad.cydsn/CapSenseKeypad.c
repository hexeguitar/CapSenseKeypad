 /* ========================================
 * Cap Sense Keypad *
 * ========================================
*/
#include <project.h>
#include "MBR3.h"
#include "CapSenseKeypad.h"
#include "mk_term.h"
#include <stdlib.h>

CY_ISR_PROTO(Keypad_INT);       //Keypad interrupt proto

const char keypadAscii[16] = {'1','2','3','4','5','6','7','8','S','9','0','.','L','D','U','R'};

volatile uint8_t capSenseKeypad_readFlag;
extern volatile uint32_t SystickDelay;

//##############################################################################
// Interrupt generated by the capsense controller, button pressed or released

CY_ISR(Keypad_INT)
{
    capSenseKeypad_readFlag = 1;
    LED_BLU_Write(0);
    SystickDelay = 10;
    Keypad_INT_ClearInterrupt();
}

//##############################################################################
uint32_t keypadHandle(void)
{
    static uint16_t keyState;
    keypadKeys_t key_pressed = KEYPAD_NONE;
    uint8_t i;
    static uint8_t tr_x = 0;
    static uint8_t tr_y = 5;
    
    keyState = MBR3Keypad_getKey();
   
    if (keyState)
    {
        for (i=0; i<16;i++)
        {    
            if (keyState & (1<<i))
            {
                key_pressed = i;
                continue;
        
            }
        }        
        switch (key_pressed)
        {
         case KEYPAD_0:   
         case KEYPAD_1:
         case KEYPAD_2:
         case KEYPAD_3:
         case KEYPAD_4:
         case KEYPAD_5:
         case KEYPAD_6:
         case KEYPAD_7:
         case KEYPAD_8:
         case KEYPAD_9:
         case KEYPAD_DOT:
                            UART_UartPutChar(keypadAscii[key_pressed]); 
                            break;
         case KEYPAD_SETUP:
                            tr_cls(0);      //clear terminal screen
                            tr_attr(MKTERM_BOLD,MKTERM_YELLOW,MKTERM_BLACK);
                            tr_locate(1,0);
                            UART_UartPutString("CapSense Keypad\r\n");
                            UART_UartPutString("(c) 2016 by Piotr Zapart\r\n");
                            tr_attr(MKTERM_RESET,MKTERM_YELLOW,MKTERM_BLACK);
                            tr_locate(5,0);
                            break;
         case KEYPAD_DOWN:
                            tr_y++;
                            if (tr_y>15) tr_y=15;
                            tr_locate(tr_y,tr_x);
                            break;
         case KEYPAD_UP:
                            if (tr_y>5) tr_y--;
                            tr_locate(tr_y,tr_x);
                            break;
         case KEYPAD_LEFT:
                            if (tr_x) tr_x--;
                            tr_locate(tr_y,tr_x);
                            break;
         case KEYPAD_RIGHT:
                            tr_x++;
                            if (tr_x > 30) tr_x = 30;
                            tr_locate(tr_y,tr_x);
                            break;
         case KEYPAD_NONE:  break;
            
        }
        
    }
    return 0;
}

//##############################################################################
// Reads out the BUTTON STATUS register (key press detected) and passes it 
// in uint16_t. The corresponding bit is set to 1 if the button is pressed.
// Default MBR3 configuration detects only one button press at a time, preventing 
// triggering adjacent buttons. This can be changed using the Cypress Ez-Click
// software if necessary.
//
// return format: 0b0000000010000000
//                          ^
//                       button pressed
//##############################################################################
uint16_t MBR3Keypad_getKey(void)
{
    uint8_t data_in[2];
    
    MBR3_readBuf(MBR3_SLAVE_ADDR,MBR3_BUTTON_STATUS,data_in,2);
   
    return (data_in[0] + (data_in[1]<<8));
}
//##############################################################################

void keypadInit(void)
{
    ISR_KeyChange_StartEx(Keypad_INT);  //start button change interrupt
    
    MBR3_init();                        //initalize MBR3 chip
}


/* [] END OF FILE */
